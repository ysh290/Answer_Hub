{"_id":"stubborn-utils","_rev":"2-2e4f5ac7d153d3ff9e1b54033164f282","name":"stubborn-utils","dist-tags":{"latest":"1.0.1"},"versions":{"1.0.0":{"name":"stubborn-utils","version":"1.0.0","keywords":["stubborn","collection","utilities","functions"],"_id":"stubborn-utils@1.0.0","maintainers":[{"name":"fabiospampinato","email":"spampinabio@gmail.com"}],"homepage":"https://github.com/fabiospampinato/stubborn-utils#readme","bugs":{"url":"https://github.com/fabiospampinato/stubborn-utils/issues"},"dist":{"shasum":"e2e32c3fab8a2dcb2465a111d15025e980338e24","tarball":"https://registry.npmjs.org/stubborn-utils/-/stubborn-utils-1.0.0.tgz","fileCount":17,"integrity":"sha512-uAwntAKPMbgvev8A7qJPxwQZmcKfhwnM17whX8EEbdyBi8DAWRdGM0jq96KBNCay06L+edPjqcf4l1AVllE63A==","signatures":[{"sig":"MEUCIBxIY0IR2YwZdHvwhhI9ut0+LiRJdAdtvwz0r7V3DexcAiEAh76KnRYgShUU369xNAR2w7DIPxsA1LQ2cpeifZB8snU=","keyid":"SHA256:DhQ8wR5APBvFHLF/+Tc+AYvPOdTpcIDqOhxsBHRwC7U"}],"unpackedSize":11365},"main":"dist/index.js","type":"module","types":"./dist/index.d.ts","exports":"./dist/index.js","scripts":{"test":"tsex test","clean":"tsex clean","compile":"tsex compile","test:watch":"tsex test --watch","compile:watch":"tsex compile --watch","prepublishOnly":"tsex prepare"},"_npmUser":{"name":"fabiospampinato","email":"spampinabio@gmail.com"},"repository":{"url":"git+https://github.com/fabiospampinato/stubborn-utils.git","type":"git"},"_npmVersion":"10.2.3","description":"A small collection of utilities for making functions somewhat resilient against errors.","directories":{},"_nodeVersion":"18.19.0","_hasShrinkwrap":false,"devDependencies":{"fava":"^0.3.5","tsex":"^4.0.2","typescript":"^5.9.3"},"_npmOperationalInternal":{"tmp":"tmp/stubborn-utils_1.0.0_1761505624388_0.2525462865895616","host":"s3://npm-registry-packages-npm-production"}},"1.0.1":{"name":"stubborn-utils","repository":{"type":"git","url":"git+https://github.com/fabiospampinato/stubborn-utils.git"},"description":"A small collection of utilities for making functions somewhat resilient against errors.","version":"1.0.1","type":"module","main":"dist/index.js","exports":"./dist/index.js","types":"./dist/index.d.ts","scripts":{"clean":"tsex clean","compile":"tsex compile","compile:watch":"tsex compile --watch","test":"tsex test","test:watch":"tsex test --watch","prepublishOnly":"tsex prepare"},"keywords":["stubborn","collection","utilities","functions"],"devDependencies":{"fava":"^0.3.5","tsex":"^4.0.2","typescript":"^5.9.3"},"_id":"stubborn-utils@1.0.1","gitHead":"7d92f526a0c6561d9e5d04fc8e385e47d86440d3","bugs":{"url":"https://github.com/fabiospampinato/stubborn-utils/issues"},"homepage":"https://github.com/fabiospampinato/stubborn-utils#readme","_nodeVersion":"18.19.0","_npmVersion":"10.2.3","dist":{"integrity":"sha512-bwtct4FpoH1eYdSMFc84fxnYynWwsy2u0joj94K+6caiPnjZIpwTLHT2u7CFAS0GumaBZVB5Y2GkJ46mJS76qg==","shasum":"e6e8feafddc255b55b08df373c98ea50310e3798","tarball":"https://registry.npmjs.org/stubborn-utils/-/stubborn-utils-1.0.1.tgz","fileCount":17,"unpackedSize":11467,"signatures":[{"keyid":"SHA256:DhQ8wR5APBvFHLF/+Tc+AYvPOdTpcIDqOhxsBHRwC7U","sig":"MEYCIQD/Kgk2zxYF0q/wo1mZjqDVV0VOJI1Nx/qvBAkyhfyjPgIhAPNiTHjGDbpeEwXNXu/Ps6N224hG3peYHVwCXxv23hr1"}]},"_npmUser":{"name":"fabiospampinato","email":"spampinabio@gmail.com"},"directories":{},"maintainers":[{"name":"fabiospampinato","email":"spampinabio@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages-npm-production","tmp":"tmp/stubborn-utils_1.0.1_1761507179052_0.1097487248836364"},"_hasShrinkwrap":false}},"time":{"created":"2025-10-26T19:07:04.387Z","modified":"2025-10-26T19:32:59.434Z","1.0.0":"2025-10-26T19:07:04.595Z","1.0.1":"2025-10-26T19:32:59.239Z"},"bugs":{"url":"https://github.com/fabiospampinato/stubborn-utils/issues"},"homepage":"https://github.com/fabiospampinato/stubborn-utils#readme","keywords":["stubborn","collection","utilities","functions"],"repository":{"type":"git","url":"git+https://github.com/fabiospampinato/stubborn-utils.git"},"description":"A small collection of utilities for making functions somewhat resilient against errors.","maintainers":[{"name":"fabiospampinato","email":"spampinabio@gmail.com"}],"readme":"# Stubborn Utils\n\nA small collection of utilities for making functions somewhat resilient against errors.\n\n## Install\n\n```sh\nnpm install stubborn-utils\n```\n\n## Usage\n\n#### `attemptifyAsync`\n\nThis function wraps an async function, and in case this wrapped function rejects then the error is automatically caught by the `onError` callback.\n\n```ts\nimport {attemptifyAsync} from 'stubborn-utils';\n\n// Let's create a wrapped function\n\nconst asyncFunction = async () => {\n  await someAsyncThing ();\n  if ( Math.random () > 0.5 ) {\n    throw new Error ( 'Unlucky' );\n  } else {\n    return 123;\n  }\n};\n\nconst attemptifiedAsyncFunction = attemptifyAsync ( asyncFunction, {\n  onError: error => {\n    return -1;\n  }\n});\n\nconst result = attemptifiedAsyncFunction (); // => Promise<123 | -1>\n```\n\n#### `attemptifySync`\n\nThis function wraps a sync function, and in case this wrapped function throws then the error is automatically caught by the `onError` callback.\n\n```ts\nimport {attemptifySync} from 'stubborn-utils';\n\n// Let's create a wrapped function\n\nconst syncFunction = () => {\n  if ( Math.random () > 0.5 ) {\n    throw new Error ( 'Unlucky' );\n  } else {\n    return 123;\n  }\n};\n\nconst attemptifiedSyncFunction = attemptifySync ( syncFunction, {\n  onError: error => {\n    return -1;\n  }\n});\n\nconst result = attemptifiedSyncFunction (); // => 123 | -1\n```\n\n#### `retryifyAsync`\n\nThis function wraps an async function, and in case this wrapped function rejects then the `isRetriable` callback is called to decide if we should retry calling the function again.\n\nThere's also another layer of options before you can actually call the retryified function, that allows you to provide a maximum `timeout` for the retry loop, and an optional `interval` that should approximately pass between retries.\n\nBefore the function is retried again a random amount of milliseconds between `0` and `interval` will be waited for.\n\nBy default `interval` would be set to `250`.\n\n```ts\nimport {retryifyAsync} from 'stubborn-utils';\n\n// Let's create a wrapped function\n\nconst asyncFunction = async () => {\n  await someAsyncThing ();\n  if ( Math.random () > 0.5 ) {\n    throw new Error ( 'Unlucky' );\n  } else {\n    return 123;\n  }\n};\n\nconst retryifiedAsyncFunction = retryifyAsync ( asyncFunction, {\n  isRetriable: error => {\n    return true; // Always retriablein this scenario\n  }\n});\n\nconst result = retryifiedAsyncFunction ({\n  timeout: 1_000,\n  interval: 100\n}); // => Promise<123 | -1>, but Promise<123> with much higher probability\n```\n\n#### `retryifySync`\n\nThis function wraps a sync function, and in case this wrapped function throws then the `isRetriable` callback is called to decide if we should retry calling the function again.\n\nThere's also another layer of options before you can actually call the retryified function, that allows you to provide a maximum `timeout` for the retry loop, and an optional `interval` that should approximately pass between retries.\n\nBefore the function is retried again a random amount of milliseconds between `0` and `interval` will be waited for.\n\nBy default `interval` would be set to `250`.\n\n```ts\nimport {retryifySync} from 'stubborn-utils';\n\n// Let's create a wrapped function\n\nconst syncFunction = () => {\n  if ( Math.random () > 0.5 ) {\n    throw new Error ( 'Unlucky' );\n  } else {\n    return 123;\n  }\n};\n\nconst retryifiedSyncFunction = retryifySync ( syncFunction, {\n  isRetriable: error => {\n    return true; // Always retriablein this scenario\n  }\n});\n\nconst result = retryifiedSyncFunction ({\n  timeout: 1_000,\n  interval: 100\n}); // => 123 | -1, but 123 with much higher probability\n```\n\n## License\n\nMIT Â© Fabio Spampinato\n","readmeFilename":"readme.md"}